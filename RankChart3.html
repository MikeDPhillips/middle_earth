<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/d3-voronoi.v1.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Montserrat:200,300,400,500,600" rel="stylesheet">
    <title>Rank Chart Example</title>
</head>
<body>

<div id="franchiseRank"></div>

<script>
    let margin = {top: 50, right: 200, bottom: 100, left: 125},
        width = 800
        height= 600
        chartWidth = width - margin.left - margin.right,
        chartHeight = height - margin.top - margin.bottom;

    let svg = d3.select("#franchiseRank").append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("id", "rankChart")
        .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

        svg.append("defs")
            .append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", chartWidth)
            .attr("height", chartHeight)

    d3.csv("franchises_medium.csv",d3.autoType).then((data)=>{
        console.log(data);
        let dateExtent = d3.extent(data, d=>d.Year);
        let countMax = d3.max(data, d=>d.Rank)
        let xScale = d3.scaleLinear().domain(dateExtent).range([0, chartWidth]);
        let yScale = d3.scaleLinear().domain([0.5, countMax+0.5]).range([0, chartHeight]);
        let yAxis = d3.axisLeft(yScale).ticks();
        let xAxis = d3.axisBottom(xScale)
            .tickFormat(d3.format("d"))
            .ticks(20)

        svg.append("g")
            //.attr("transform","translate(" + margin.left + "," + margin.top + ")")
            .attr("transform", "translate(-10,0)")
            .call(yAxis);

        svg.append("g")
            .attr("transform", "translate("+ 0 + "," + (chartHeight + 9) + ")")
            .call(xAxis);


       let voronoi = d3.voronoi()
            .x(d => xScale(d['Year']))
            .y(d => yScale(d['Rank']))
            .extent([[-margin.left , -margin.top], [width + margin.right, height + margin.bottom ]]);

        let line = d3.line()
            .x(d => xScale(d['Year']))
            .y(d => yScale(d['Rank']))
                // Uncomment this to use monotone curve
          //    	.curve(d3.curveMonotoneX);



        var orderedData = [];
        data.forEach((d) => {
            var dObj = {Franchise: d.Franchise, Rankings: []};
            for (let year in d) {
                if (year != "department") {
                    if (d[year] != 0) {
                        dObj.ranks.push({year: +year, rank: +d[year], department: dObj});
                    }
                }
            }
            parsedData.push(dObj);
        });

        let nestedData =  d3.group(data, d=>d['Franchise'])
        let keyValue = Array.from(nestedData, ([key, value]) => ({key, value}))

        //Choose colors for each franchise
        let names = [...new Set(data.map(d => d.Franchise))];
        console.log(names)
        let colorScale = d3.scaleOrdinal().domain(names)
            .range(['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffbe33','#a65628','#f781bf','#4ec0c2'])


        let lines = svg.append("g")
            .selectAll("path")
            .data(data)
            .enter().append("path")
            .attr("class", "rank-line")
            .attr("d", function(d) { d.line = this; return line(d)})
            .attr("clip-path", "url(#clip)")
            .style("stroke", d => colour(d.Franchise)
            .style("stroke-width", 10)
            .style("opacity", 0.1)
            // .transition()
            // .duration(500)
            // .delay(d => (highlight.indexOf(d.department) + 1) * 500)
            // .style("opacity", d => highlight.includes(d.department) ? 1 : 0.1);


        let endLabels = svg.append("g")
            .attr("class", "end-labels")
            .selectAll("text")
            .data(data)
            .enter().append("text")
            .attr("class", "end-label")
            .attr("x", d => x(d[d.ranks.length - 1].year))
            .attr("y", d => y(d.ranks[d.ranks.length - 1].rank))
            .attr("dx", 20)
            .attr("dy", cfg.strokeWidth / 2)
            .text(d => d.department)
            .style("opacity", 0)
            .transition()
            .duration(500)
            .delay(d => (highlight.indexOf(d.department) + 1) * 500)
            .style("opacity", 1);

        var endDots = svg.append("g")
            .selectAll("circle")
            .data(parsedData.filter(d => highlight.includes(d.department)))
            .enter().append("circle")
            .attr("class", "end-circle")
            .attr("cx", d => x(d.ranks[d.ranks.length - 1].year))
            .attr("cy", d => y(d.ranks[d.ranks.length - 1].rank))
            .attr("r", cfg.strokeWidth)
            .style("fill", d => colour(d.department))
            .style("opacity", 0)
            .transition()
            .duration(500)
            .delay(d => (highlight.indexOf(d.department) + 1) * 500)
            .style("opacity", 1);

        var tooltip = svg.append("g")
            .attr("transform", "translate(-100, -100)")
            .attr("class", "tooltip");
        tooltip.append("circle")
            .attr("r", cfg.strokeWidth);
        tooltip.append("text")
            .attr("class", "name")
            .attr("y", -20);

        let voronoiGroup = svg.append("g")
            .attr("class", "voronoi");

        voronoiGroup.selectAll("path")
            .data(voronoi.polygons(d3.merge(parsedData.map(d => d.ranks))))
            .enter().append("path")
            .attr("d", function(d) { return d ? "M" + d.join("L") + "Z" : null; })
            .on("mouseover", mouseover)
            .on("mouseout", mouseout);

        svg.selectAll(".rank-line")
            .each(d => highlight.includes(d.department) ? d.line.parentNode.appendChild(d.line) : 0);

        svg.select("g.end-labels").raise();

        function mouseover(d) {
            // Hide labels and dots from initial animation
            svg.selectAll(".end-label").style("opacity", 0);
            svg.selectAll(".end-circle").style("opacity", 0);

            svg.selectAll(".rank-line").style("opacity", 0.1);
            d3.select(d.data.department.line).style("opacity", 1);
            d.data.department.line.parentNode.appendChild(d.data.department.line);
            tooltip.attr("transform", "translate(" + x(d.data.year) + "," + y(d.data.rank) + ")")
                .style("fill", colour(d.data.department.department))
            tooltip.select("text").text(d.data.department.department)
                .attr("text-anchor", d.data.year == x.domain()[0] ? "start" : "middle")
                .attr("dx", d.data.year == x.domain()[0] ? -10 : 0)
        }

        function mouseout(d) {
            svg.selectAll(".rank-line").style("opacity", d => highlight.includes(d.department) ? 1 : 0.1);

            svg.selectAll(".end-label").style("opacity", 1);
            svg.selectAll(".end-circle").style("opacity", 1);
            tooltip.attr("transform", "translate(-100,-100)");
        }
    });





    });
</script>

</body>
</html>